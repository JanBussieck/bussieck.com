{"componentChunkName":"component---src-templates-post-js","path":"/on-writing-software-well-part-1/","result":{"data":{"ghostPost":{"id":"Ghost__Post__5e7383d91baf0e7fa30dd890","title":"'On Writing Software Well' Part I","slug":"on-writing-software-well-part-1","featured":false,"feature_image":"https://images.unsplash.com/photo-1556742044-3c52d6e88c62?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ","excerpt":"We're looking at DHH's series to talk about software design using real world software with alls its trade-offs, necessary messiness and complexity so neatly omitted in your standard textbook toy examples.","custom_excerpt":"We're looking at DHH's series to talk about software design using real world software with alls its trade-offs, necessary messiness and complexity so neatly omitted in your standard textbook toy examples.","visibility":"public","created_at_pretty":"19 March, 2020","published_at_pretty":"19 March, 2020","updated_at_pretty":"19 March, 2020","created_at":"2020-03-19T14:38:17.000+00:00","published_at":"2020-03-19T15:57:00.000+00:00","updated_at":"2020-03-19T21:24:54.000+00:00","meta_title":"Ruby on Rails: Writing Software Well Part 1","meta_description":"Part 1 deals with expressive constants and code colocation and the dos and donts of using exception as control flow.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Jan Bussieck","slug":"jan","bio":null,"profile_image":"//www.gravatar.com/avatar/e056f0b055ea37bd94fdc1664fca6e3d?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Jan Bussieck","slug":"jan","bio":null,"profile_image":"//www.gravatar.com/avatar/e056f0b055ea37bd94fdc1664fca6e3d?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Ruby on Rails","slug":"ruby-on-rails","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Ruby on Rails","slug":"ruby-on-rails","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Software Design","slug":"software-design","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Tech","slug":"tech","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"DHH has drawn back the curtain on how Basecamp writes software in a video\nseries, tentatively titled 'On Writing Software (well?)', I find it highly\ninstructive and valuable to talk about software design using real world software\nwith alls its trade-offs, necessary messiness and complexity so neatly omitted\nin your standard textbook toy examples.\n\nWhile I do lay out the contents of each episode, this is not a series plain\ntranscript, but rather a way for me to engage with the challenges raised in DHHs\nexamples, add my own thoughts and, at times, contrast his approach with the one\nwe took for speqtor.com [http://speqtor.com] sharing examples from our code\nbase.\n\nEpisode 1\nWhile Code comments are sometimes necessary to explain certain decisions or\ntrade-offs that aren't obvious from the code, more often than not comments are a\nkind of code smell. \n\nYou should ask yourself why am I writing this comment? How could the code itself\nbe clearer and not need this comment?\n\nEvery developer is familiar with arcane, outdated comments in the midst of\nseemingly unrelated code, because the related code had been deleted. Another\nadvantage of self-explanatory code apart from just being clearer (by definition)\nis that it preempts the problem of code and its explanation getting out of sync.\n\ndef remove_inaccessible_records\n  # 30s of forgiveness in case of accidental removal\n  unless person.destroyed? || bucket.destroyed\n    Person::RemoveInaccessibleRecordJob.set(wait: 30.seconds).perform_later(person, bucket)\n  end\nend\n\nThe Basecamp codebase includes a method to remove all inaccessible records after\na user has been deleting, because restoring a user's objects in the bucket is\ncumbersome a 30 second grace period was added in case a user is accidentally\nremoved.\n\nA comment explains not the control flow, but the configuration of the job.\n\nWe could simply add an explanatory variable elucidating the magic value of 30\nseconds and hinting at its purpose.\n\ndef remove_inaccessible_records\n  grace_period_removing_inaccessible_records = 30.seconds\n\n  unless person.destroyed? || bucket.destroyed?\n    Person::RemoveInaccessibleRecordJob.set(wait: 30.seconds).perform_later(person, bucket)\n  end\nend\n\nHowever, the value does not vary, so why store it in a variable, it should be a\nconstant. But instead of defining it at the top of the file, as we idiomatically\nwould for public constants in ruby, we should prefer colocating related code and\nmaking the constant private.\n\nprivate\nGRACE_PERIOD_REMOVING_INACCESSIBLE_RECORDS = 30.seconds\n\ndef remove_inaccessible_records\n  unless person.destroyed? || bucket.destroyed?\n  Person::RemoveInaccessibleRecordJob.set(\n    wait: GRACE_PERIOD_REMOVING_INACCESSIBLE_RECORDS\n  ).perform_later(person, bucket)\n  end\nend\n\nI would go a step further and separate configuration from my app code,\nespecially since often you might want to have different values for different\nenvironments, for instance in testing environment you might want the job to\nexecute immediately and not wait 30 seconds.\n\nMore importantly, I have a central place to go looking for configuration options\nin my applications and they're not scattered across my source code. In Speqtor,\nfor example, we only send out a notification if no new notifications for a user\nwere scheduled within a certain cool down period, so as not to clog up their\ninbox.\n\nThe config options are defined in config/notifications.yml\n\nproduction:\n  cool_off_period_in_minutes: 20\ndevelopment:\n  cool_off_period_in_minutes: 0.2\ntest:\n  cool_off_period_in_minutes: 0\n\nand included it in application.rb  under the rails namespace config.x for\ncustom\nconfiguration.\n[https://guides.rubyonrails.org/configuring.html#custom-configuration]\n\nconfig.x.notification = config_for(:notification)\n\nBack to DHH, who show us an example of how some of his refactorings lead to new\nfeatures in Rails. In Basecamp there is a join model for granting users\nadministrative access to certain resource and a helper method grant that accepts\na person argument and creates an entry for the person in the join model, if an\nentry already exists it simply returns the person record.\n\nWhat might jump out at you about this method is that it commits the sin of using\nan exception for controlling flow. The dual offense of using framework\nexceptions in your code is that it also mixes two different levels of\nabstraction, in this case the top-level ActiveRecord API and constants from the\nbowels of ActiveRecord.\n\nmodule Account::Administered\n  extend ActiveSupport::Concern\n\n  included do\n    has_many :administratorships\n\n    def grant(person)\n\t  create! person: person\n        rescue ActiveRecord::RecordNotUnique\n        # don't worry about dupes. Treat them the same as successful creation\n        where(person: person).take\n      end\n    end\n  end\nend\n\nThe reason we are avoiding ActiveRecord's find_or_initialize_by here is that we\nmight end up with stale reads, as find_or_initialize_by first checks whether a\nrecord with the attributes exists using a where query and returns it if it does\nor else creates one with those attributes.\n\nIn applications with high load this could lead to the result returned by the \nwhere clause to being outdated, in which case the create might fail, because the\nrecord has already been created in the interim. Hence, we are first attempting\nto create the record and if that fails because it already exists we simply\nreturn it.\n\nSo what we actually want is create_of_find_by(person: person) which encapsulate\nthis behavior and simplifies this code to a mere delegation:\n\ndef grant(person)\n  create_or_find_by(person: person)\nend\n\nAnd indeed, this method has made it into Rails 6 and it's arguably what \nfind_or_create_by should have been from the beginning.\n\nJust a note on the topic of exceptions as a flow control; in this instance, I\nthink it is perfectly fine to do so (and in fact the Rails method does just that\n[https://github.com/rails/rails/blob/f675cb30ce813a99b52b139a93e048330922fd9a/activerecord/lib/active_record/relation.rb#L218]\n), because we are relying on the database's mechanism for ensuring data\nconsistency and simply pass the exception through to the caller. We could not\nhave performed this check without dealing with the database exception, since\nthis is the only interface offered to our application code.","html":"<p>DHH has drawn back the curtain on how Basecamp writes software in a video series, tentatively titled 'On Writing Software (well?)', I find it highly instructive and valuable to talk about software design using real world software with alls its trade-offs, necessary messiness and complexity so neatly omitted in your standard textbook toy examples.</p><p>While I do lay out the contents of each episode, this is not a series plain transcript, but rather a way for me to engage with the challenges raised in DHHs examples, add my own thoughts and, at times, contrast his approach with the one we took for <a href=\"http://speqtor.com\">speqtor.com</a> sharing examples from our code base.</p><h2 id=\"episode-1\">Episode 1</h2><p>While Code comments are sometimes necessary to explain certain decisions or trade-offs that aren't obvious from the code, more often than not comments are a kind of code smell. </p><p>You should ask yourself <em>why</em> am I writing this comment? How could the code itself be clearer and not need this comment?</p><p>Every developer is familiar with arcane, outdated comments in the midst of seemingly unrelated code, because the related code had been deleted. Another advantage of self-explanatory code apart from just being clearer (by definition) is that it preempts the problem of code and its explanation getting out of sync.</p><pre><code class=\"language-ruby\">def remove_inaccessible_records\n  # 30s of forgiveness in case of accidental removal\n  unless person.destroyed? || bucket.destroyed\n    Person::RemoveInaccessibleRecordJob.set(wait: 30.seconds).perform_later(person, bucket)\n  end\nend</code></pre><p>The Basecamp codebase includes a method to remove all inaccessible records after a user has been deleting, because restoring a user's objects in the bucket is cumbersome a 30 second grace period was added in case a user is accidentally removed.</p><p>A comment explains not the control flow, but the configuration of the job.</p><p>We could simply add an <em>explanatory variable</em> elucidating the magic value of 30 seconds and hinting at its purpose.</p><pre><code class=\"language-ruby\">def remove_inaccessible_records\n  grace_period_removing_inaccessible_records = 30.seconds\n\n  unless person.destroyed? || bucket.destroyed?\n    Person::RemoveInaccessibleRecordJob.set(wait: 30.seconds).perform_later(person, bucket)\n  end\nend</code></pre><p>However, the value does not vary, so why store it in a variable, it should be a constant. But instead of defining it at the top of the file, as we idiomatically would for public constants in ruby, we should prefer colocating related code and making the constant private.</p><pre><code class=\"language-ruby\">private\nGRACE_PERIOD_REMOVING_INACCESSIBLE_RECORDS = 30.seconds\n\ndef remove_inaccessible_records\n  unless person.destroyed? || bucket.destroyed?\n  Person::RemoveInaccessibleRecordJob.set(\n    wait: GRACE_PERIOD_REMOVING_INACCESSIBLE_RECORDS\n  ).perform_later(person, bucket)\n  end\nend</code></pre><p>I would go a step further and separate configuration from my app code, especially since often you might want to have different values for different environments, for instance in testing environment you might want the job to execute immediately and not wait 30 seconds.</p><p>More importantly, I have a central place to go looking for configuration options in my applications and they're not scattered across my source code. In Speqtor, for example, we only send out a notification if no new notifications for a user were scheduled within a certain cool down period, so as not to clog up their inbox.</p><p>The config options are defined in <code>config/notifications.yml</code></p><pre><code class=\"language-ruby\">production:\n  cool_off_period_in_minutes: 20\ndevelopment:\n  cool_off_period_in_minutes: 0.2\ntest:\n  cool_off_period_in_minutes: 0</code></pre><p>and included it in application.rb  under the rails namespace config.x <a href=\"https://guides.rubyonrails.org/configuring.html#custom-configuration\" rel=\"noopener noreferrer\">for custom configuration.</a></p><p><code>config.x.notification = config_for(:notification)</code></p><p>Back to DHH, who show us an example of how some of his refactorings lead to new features in Rails. In Basecamp there is a join model for granting users administrative access to certain resource and a helper method <code>grant</code> that accepts a <code>person</code> argument and creates an entry for the person in the join model, if an entry already exists it simply returns the person record.</p><p>What might jump out at you about this method is that it commits the sin of using an exception for controlling flow. The dual offense of using framework exceptions in your code is that it also mixes two different levels of abstraction, in this case the top-level ActiveRecord API and constants from the bowels of ActiveRecord.</p><pre><code class=\"language-ruby\">module Account::Administered\n  extend ActiveSupport::Concern\n\n  included do\n    has_many :administratorships\n\n    def grant(person)\n\t  create! person: person\n        rescue ActiveRecord::RecordNotUnique\n        # don't worry about dupes. Treat them the same as successful creation\n        where(person: person).take\n      end\n    end\n  end\nend</code></pre><p>The reason we are avoiding ActiveRecord's <code>find_or_initialize_by</code> here is that we might end up with stale reads, as <code>find_or_initialize_by</code>  first checks whether a record with the attributes exists using a <code>where</code> query and returns it if it does or else creates one with those attributes.</p><p>In applications with high load this could lead to the result returned by the <code>where</code> clause to being outdated, in which case the create might fail, because the record has already been created in the interim. Hence, we are first attempting to create the record and if that fails because it already exists we simply return it.</p><p>So what we actually want is <code>create_of_find_by(person: person)</code> which encapsulate this behavior and simplifies this code to a mere delegation:</p><pre><code class=\"language-ruby\">def grant(person)\n  create_or_find_by(person: person)\nend</code></pre><p>And indeed, this method has made it into Rails 6 and it's arguably what <code>find_or_create_by</code> should have been from the beginning.</p><p>Just a note on the topic of exceptions as a flow control; in this instance, I think it is perfectly fine to do so (<a href=\"https://github.com/rails/rails/blob/f675cb30ce813a99b52b139a93e048330922fd9a/activerecord/lib/active_record/relation.rb#L218\">and in fact the Rails method does just that</a>), because we are relying on the database's mechanism for ensuring data consistency and simply pass the exception through to the caller. We could not have performed this check without dealing with the database exception, since this is the only interface offered to our application code.</p>","url":"http://localhost:2368/on-writing-software-well-part-1/","canonical_url":null,"uuid":"417d7f35-e02b-4545-840b-0bea7d642e0e","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5e7383d91baf0e7fa30dd890","reading_time":4}},"pageContext":{"slug":"on-writing-software-well-part-1"}}}