{"componentChunkName":"component---src-templates-tag-js","path":"/tag/hooks/","result":{"data":{"ghostTag":{"slug":"hooks","name":"hooks","visibility":"public","feature_image":null,"description":null,"meta_title":null,"meta_description":null},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__5e9d7c13fb708a9e1ad89877","title":"useEffect under the Hood","slug":"useeffect-under-the-hood","featured":false,"feature_image":"https://images.unsplash.com/photo-1560024253-570f054dea63?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ","excerpt":"To deepen our understanding of the inner workings of useEffect and how it relates to the lifecycle of a component we take a look at React's source code.","custom_excerpt":"To deepen our understanding of the inner workings of useEffect and how it relates to the lifecycle of a component we take a look at React's source code.","visibility":"public","created_at_pretty":"20 April, 2020","published_at_pretty":"20 April, 2020","updated_at_pretty":"20 April, 2020","created_at":"2020-04-20T10:40:19.000+00:00","published_at":"2020-04-20T11:16:19.000+00:00","updated_at":"2020-04-20T17:30:44.000+00:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Jan Bussieck","slug":"jan","bio":null,"profile_image":"//www.gravatar.com/avatar/e056f0b055ea37bd94fdc1664fca6e3d?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Jan Bussieck","slug":"jan","bio":null,"profile_image":"//www.gravatar.com/avatar/e056f0b055ea37bd94fdc1664fca6e3d?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"hooks","slug":"hooks","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"hooks","slug":"hooks","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"react","slug":"react","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Tech","slug":"tech","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"The best way I have found to really have an accurate mental model of the\nprogramming abstractions I use whether compilers, promises or frameworks like\nreact, it is to crack open the blackbox and understand the essential\nimplementation details.\nWhile there are a number of excellent posts on how hooks work under the hood\n[https://www.netlify.com/blog/2019/03/11/deep-dive-how-do-react-hooks-really-work/]\n, the inner workings of useEffect and how it relates to the lifecycle of a\ncomponent continue to be a source of puzzlement for many.\nAs I’ll attempt to show when you peak behind the curtain the useEffect hook’s\nimplementation is quite straightforward and fits elegantly into React’s\nreconciliation algorithm.\nBy the end I hope we’ll be able to confidently answer questions such as:\n\n * Why do we have to call useEffect in the same order?\n * How are hooks represented by a fibre?\n * How exactly are values in the dependency array compared?\n * When and how are effects cleaned up?\n * Why can’t I take advantage of React fibre in my useEffect callbacks?\n\nFirst, let’s briefly recap how React fibers and the reconciliation algorithm\nwork; during reconciliation React builds up a work-in-progress fiber tree and\ncomputes a set of changes computed by walking the component tree and recursively\ncalling render. So each React element is turned into a fiber node of\ncorresponding type\n[https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/shared/ReactWorkTags.js] \nthat keeps record of the work to be done building up a work in progress tree.\nThink of a fiber as representing a unit of work that can be independently\nscheduled, paused and aborted.\nWhen an update is called React will add the update to a component update queue,\nfor instance, when setState was called on render React calls the updater\nfunction which was passed into setState. After the updater is finished the fiber\ngets a tag that a change needs to be made in the DOM.\nThe list of changes are propagated up to the parent fiber and merged into its\nlist of changes. This list of changes is also called effect list. Now the work\nin progress tree is marked as a pending commit.\n\nThose changes are not immediately committed to a rendering target such as the\nDOM.  That happens in the commit phase, this phase is atomic and cannot be\ninterrupted, otherwise there might be UI inconsistencies.\nDuring the commit phase React iterates over the effect list and makes its\nchanges to the rendering target (e.g. DOM).\n\nLet’s look at some code:\nuseEffect is defined in ReactHooks.js and its type signature clues us in to how\nit works; it accepts as first argument a function creating the effect, which\noptionally returns a function (cleaning up the effect) and as second argument\neither an optional array of inputs (the dependency array) of varying type.\nWe see that the functions first resolves a dispatcher and then delegates to it.\n\n//react/blob/master/packages/react/src/ReactHooks.js#L104\nexport function useEffect(\n  create: () => (() => void) | void,\n  inputs: Array<mixed> | void | null,\n) {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useEffect(create, inputs);\n}\n\n\nThe hook dispatchers are resolved depending on the current context, if it's the\ninitial render and the component just mounted HooksDispatcherOnMount and\notherwise HooksDispatcherOnUpdate is returned, correspondingly the dispatcher\nreturns either mountEffect or updateEffect.\n\n//react/blob/master/packages/react-reconciler/src/ReactFiberHooks.old.js#L570\nconst HooksDispatcherOnMount: Dispatcher = {\n\t...\n  useEffect: mountEffect,\n  ...\n};\n\nconst HooksDispatcherOnUpdate: Dispatcher = {\n  ...\n  useEffect: updateEffect,\n  ...\n}\n\n\nWithout looking at the implementation from our experience working with useEffect \nwe know that these cases differ in at least one respect; the create function of \nuseEffect is always invoked on mount, regardless of its second argument.\n\nLet us first look at the more common update case. updateEffect delegates to \nupdateEffectImpl to pass in the current fiber and hook effect tags. I don’t want\nto go too much into effect tags here, suffice it to mention that each fiber’s\neffects are encoded in an effectTag, they define  thework\n[https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/shared/ReactSideEffectTags.js] \nthat needs to be done for instances after updates have been processed, similarly\nthere are hook effect tags carrying information about the hook effect's context,\ne.g. whether the component is unmounting or whether the effect should be invoked\nat all (the NoHookEffect tag).\nupdateEffectImpl first calls updateWorkInProgress to get a new hook instance,\nwhich is basically just a clone of the current hook or if we are in a\nwork-in-progress tree the current work-in-progress hook:\n\nconst newHook: Hook = {\n  memoizedState: currentHook.memoizedState,\n\n  baseState: currentHook.baseState,\n  queue: currentHook.queue,\n  baseUpdate: currentHook.baseUpdate,\n\n  next: null,\n};\n\n\nWhen a hook is called in our component it builds up a queue where hooks are\nrepresented as linked list in their call order with each hook’s next field\npointing to the next hook. Since these are copied over from each render, we see\nwhy we cannot call hooks conditionally or change their call order from render to\nrender.\nThe baseState and baseUpdate fields are relevant to useState and useDispatch \nhooks,useEffect most importantly uses memoizedState to hold a reference to the\nprevious effect. Let’s look at why.\n\n//react/packages/react-reconciler/src/ReactFiberHooks.old.js#L1218\nfunction updateEffectImpl(fiberEffectTag, hookEffectTag, create, deps): void {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  let destroy = undefined;\n\n  if (currentHook !== null) {\n    const prevEffect = currentHook.memoizedState;\n    destroy = prevEffect.destroy;\n    if (nextDeps !== null) {\n      const prevDeps = prevEffect.deps;\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        pushEffect(NoHookEffect, create, destroy, nextDeps);\n        return;\n      }\n    }\n  }\n\n  sideEffectTag |= fiberEffectTag;\n  hook.memoizedState = pushEffect(hookEffectTag, create, destroy, nextDeps);\n}\n\n\nThe most interesting thing happening here is that if there is a currentHook we\nfetch the previous effect from the hook’s memoizedState field to get the\nprevious dependencies and compare them to the next dependencies. If they are\nequal we push an effect onto the queue with the NoHookEffect tag and return,\nwhich means that the effect will still be run during commit, but it won’t be\nexecuted (its create function won't be invoked). Finally, if the dependencies\nare not equal, we push the effect onto the queue with an effect tag that ensures\nthe effect will fire.\nAs a side note areHookInputsEqual delegates to Object.is instead of a plain\nobject reference comparison to catch javascript quirks such as NaN === NaN //\nfalse.\n\nWe skip over the source ofmountEffectImpl here, since it only differs from \nupdateEffectImpl in that it does not check the dependency array and simply\npushes the hook on the effect queue to be executed.\n\nThat is basically all that happens during reconciliation; values from previous\nuseEffect hooks are cloned, the new dependencies compared to previous ones which\nwere saved on the memoizedState field to determine whether the effect should\nfire or not and that information is pushed on the effect queue.\n\nThe next time we see our effect is after React has finished reconciliation,\nevery render has been called and the list of updates to be committed to the\nrendering target aggregated. We are in the commit phase now and commitWork calls \ncommitHookEffectList:\n\nfunction commitWork(current: Fiber | null, finishedWork: Fiber): void {\n\t...\n  commitHookEffectList(UnmountMutation, MountMutation, finishedWork);\n\t...\n}\n\n\n commitHookEffectList in turn iterates over the effect list, checks the tag to\ndetermine in which phase the effect has been added to the list and fires create \nor destroy respectively.\nWe see that in the case of an unmountTag the destroy clean up function is\ncalled. In case, we are in an update phase, create is called firing the effect,\nbut destroy is simply saved on the effect for future reference in the unmount\nphase. If the effect has been tagged with NoHookEffect it is simply skipped.\n\n// react/ReactFiberCommitWork.old.js at master · facebook/react\nfunction commitHookEffectList(\n  unmountTag: number,\n  mountTag: number,\n  finishedWork: Fiber,\n) {\n  const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any);\n  let lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n  if (lastEffect !== null) {\n    const firstEffect = lastEffect.next;\n    let effect = firstEffect;\n    do {\n      if ((effect.tag & unmountTag) !== NoHookEffect) {\n        // Unmount\n        const destroy = effect.destroy;\n        effect.destroy = undefined;\n        if (destroy !== undefined) {\n          destroy();\n        }\n      }\n      if ((effect.tag & mountTag) !== NoHookEffect) {\n        // Mount\n        const create = effect.create;\n        effect.destroy = create();\n\n        if (__DEV__) {...}\n      }\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n\n\nNow we also see why the code we run in useEffect cannot take advantage of fibers\nwhich are able to pause in order to let other higher priority work finish before\nrendering is resumed. This is because the effect is executed inside of \ncommitWork which makes atomic changes to the rendering target to avoid UI\ninconsistencies. This is important to bear in mind lest one is tempted to\nperform computationally intensive, synchronous work inside a useEffect hook.\n\nI hope this basic understanding of how useEffect works under the hood in mind\nhelps you become more confident working with useEffect and avoid common\npitfalls. It may also have encouraged you to pull away the curtain once in a\nwhile and take a look at the React source to deepen your understanding. The most\ndifficult to understand parts of the code are often related to performance and\nother house-keeping, but you shouldn't let that shroud your understanding of the\ncentral pieces that are concerned with React’s core functionality.\nHappy source reading!","html":"<p>The best way I have found to really have an accurate mental model of the programming abstractions I use whether compilers, promises or frameworks like react, it is to crack open the blackbox and understand the essential implementation details.<br>While there are a number of excellent posts on <a href=\"https://www.netlify.com/blog/2019/03/11/deep-dive-how-do-react-hooks-really-work/\">how hooks work under the hood</a>, the inner workings of useEffect and how it relates to the lifecycle of a component continue to be a source of puzzlement for many.<br>As I’ll attempt to show when you peak behind the curtain the <code>useEffect</code> hook’s implementation is quite straightforward and fits elegantly into React’s reconciliation algorithm.<br>By the end I hope we’ll be able to confidently answer questions such as:</p><ul><li>Why do we have to call <code>useEffect</code> in the same order?</li><li>How are hooks represented by a fibre?</li><li>How exactly are values in the dependency array compared?</li><li>When and how are effects cleaned up?</li><li>Why can’t I take advantage of React fibre in my useEffect callbacks?</li></ul><p>First, let’s briefly recap how React fibers and the reconciliation algorithm work; during reconciliation React builds up a work-in-progress fiber tree and computes a set of changes computed by walking the component tree and recursively calling <code>render</code>. So each React element is turned into a fiber node of  <a href=\"https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/shared/ReactWorkTags.js\">corresponding type</a>  that keeps record of the work to be done building up a work in progress tree. Think of a fiber as representing a unit of work that can be independently scheduled, paused and aborted.<br>When an update is called React will add the update to a component update queue, for instance, when setState was called on render React calls the updater function which was passed into setState. After the updater is finished the fiber gets a <em>tag</em> that a change needs to be made in the DOM.<br>The list of changes are propagated up to the parent fiber and merged into its list of changes. This list of changes is also called <em>effect list</em>. Now the work in progress tree is marked as a pending commit.</p><p>Those changes are not immediately committed to a rendering target such as the DOM.  That happens in the <em>commit</em> phase, this phase is atomic and cannot be interrupted, otherwise there might be UI inconsistencies.<br>During the commit phase React iterates over the effect list and makes its changes to the rendering target (e.g. DOM).</p><p>Let’s look at some code:<br><code>useEffect</code> is defined in <code>ReactHooks.js</code> and its type signature clues us in to how it works; it accepts as first argument a function creating the effect, which optionally returns a function (cleaning up the effect) and as second argument either an optional array of inputs (the dependency array) of varying type.<br>We see that the functions first resolves a dispatcher and then delegates to it.</p><pre><code class=\"language-javascript\">//react/blob/master/packages/react/src/ReactHooks.js#L104\nexport function useEffect(\n  create: () =&gt; (() =&gt; void) | void,\n  inputs: Array&lt;mixed&gt; | void | null,\n) {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useEffect(create, inputs);\n}\n</code></pre><p>The hook dispatchers are resolved depending on the current context, if it's the initial render and the component just mounted <code>HooksDispatcherOnMount</code> and otherwise <code>HooksDispatcherOnUpdate</code> is returned, correspondingly the dispatcher returns either <code>mountEffect</code> or <code>updateEffect</code>.</p><pre><code class=\"language-javascript\">//react/blob/master/packages/react-reconciler/src/ReactFiberHooks.old.js#L570\nconst HooksDispatcherOnMount: Dispatcher = {\n\t...\n  useEffect: mountEffect,\n  ...\n};\n\nconst HooksDispatcherOnUpdate: Dispatcher = {\n  ...\n  useEffect: updateEffect,\n  ...\n}\n</code></pre><p>Without looking at the implementation from our experience working with <code>useEffect</code> we know that these cases differ in at least one respect; the create function of <code>useEffect</code> is always invoked on mount, regardless of its second argument.</p><p>Let us first look at the more common update case. <code>updateEffect</code> delegates to <code>updateEffectImpl</code>  to pass in the current fiber and hook effect tags. I don’t want to go too much into effect tags here, suffice it to mention that each fiber’s effects are encoded in an <code>effectTag</code>, they define  the  <a href=\"https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/shared/ReactSideEffectTags.js\">work</a>  that needs to be done for instances after updates have been processed, similarly there are hook effect tags carrying information about the hook effect's context, e.g. whether the component is unmounting or whether the effect should be invoked at all (the <code>NoHookEffect</code> tag).<br><code>updateEffectImpl</code> first calls <code>updateWorkInProgress</code> to get a new hook instance, which is basically just a clone of the current hook or if we are in a work-in-progress tree the current work-in-progress hook:</p><pre><code class=\"language-javascript\">const newHook: Hook = {\n  memoizedState: currentHook.memoizedState,\n\n  baseState: currentHook.baseState,\n  queue: currentHook.queue,\n  baseUpdate: currentHook.baseUpdate,\n\n  next: null,\n};\n</code></pre><p>When a hook is called in our component it builds up a queue where hooks are represented as linked list in their call order with each hook’s <code>next</code> field pointing to the next hook. Since these are copied over from each render, we see why we cannot call hooks conditionally or change their call order from render to render.<br>The <code>baseState</code> and <code>baseUpdate</code> fields are relevant to <code>useState</code> and <code>useDispatch</code> hooks,  <code>useEffect</code> most importantly uses <code>memoizedState</code> to hold a reference to the previous effect. Let’s look at why.</p><pre><code class=\"language-javascript\">//react/packages/react-reconciler/src/ReactFiberHooks.old.js#L1218\nfunction updateEffectImpl(fiberEffectTag, hookEffectTag, create, deps): void {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  let destroy = undefined;\n\n  if (currentHook !== null) {\n    const prevEffect = currentHook.memoizedState;\n    destroy = prevEffect.destroy;\n    if (nextDeps !== null) {\n      const prevDeps = prevEffect.deps;\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        pushEffect(NoHookEffect, create, destroy, nextDeps);\n        return;\n      }\n    }\n  }\n\n  sideEffectTag |= fiberEffectTag;\n  hook.memoizedState = pushEffect(hookEffectTag, create, destroy, nextDeps);\n}\n</code></pre><p>The most interesting thing happening here is that if there is a <code>currentHook</code> we fetch the previous effect from the hook’s <code>memoizedState</code> field to get the previous dependencies and compare them to the next dependencies. If they are equal we push an effect onto the queue with the <code>NoHookEffect</code> tag and return, which means that the effect will still be run during commit, but it won’t be executed (its <code>create</code> function won't be invoked). Finally, if the dependencies are not equal, we push the effect onto the queue with an effect tag that ensures the effect will fire.<br>As a side note <code>areHookInputsEqual</code> delegates to <code>Object.is</code> instead of a plain object reference comparison to catch javascript quirks such as <code>NaN === NaN // false</code>.</p><p>We skip over the source of<code>mountEffectImpl</code> here, since it only differs from <code>updateEffectImpl</code> in that it does not check the dependency array and simply pushes the hook on the effect queue to be executed.</p><p>That is basically all that happens during reconciliation; values from previous useEffect hooks are cloned, the new dependencies compared to previous ones which were saved on the <code>memoizedState</code> field to determine whether the effect should fire or not and that information is pushed on the effect queue.</p><p>The next time we see our effect is after React has finished reconciliation, every render has been called and the list of updates to be committed to the rendering target aggregated. We are in the commit phase now and <code>commitWork</code> calls <code>commitHookEffectList</code>:</p><pre><code class=\"language-javascript\">function commitWork(current: Fiber | null, finishedWork: Fiber): void {\n\t...\n  commitHookEffectList(UnmountMutation, MountMutation, finishedWork);\n\t...\n}\n</code></pre><p> <code>commitHookEffectList</code> in turn iterates over the effect list, checks the tag to determine in which phase the effect has been added to the list and fires <code>create</code> or <code>destroy</code> respectively.<br>We see that in the case of an <code>unmountTag</code>  the <code>destroy</code> clean up function is called. In case, we are in an update phase, <code>create</code> is called firing the effect, but <code>destroy</code> is simply saved on the effect for future reference in the unmount phase. If the effect has been tagged with <code>NoHookEffect</code> it is simply skipped.</p><pre><code class=\"language-javascript\">// react/ReactFiberCommitWork.old.js at master · facebook/react\nfunction commitHookEffectList(\n  unmountTag: number,\n  mountTag: number,\n  finishedWork: Fiber,\n) {\n  const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any);\n  let lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n  if (lastEffect !== null) {\n    const firstEffect = lastEffect.next;\n    let effect = firstEffect;\n    do {\n      if ((effect.tag &amp; unmountTag) !== NoHookEffect) {\n        // Unmount\n        const destroy = effect.destroy;\n        effect.destroy = undefined;\n        if (destroy !== undefined) {\n          destroy();\n        }\n      }\n      if ((effect.tag &amp; mountTag) !== NoHookEffect) {\n        // Mount\n        const create = effect.create;\n        effect.destroy = create();\n\n        if (__DEV__) {...}\n      }\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n</code></pre><p>Now we also see why the code we run in <code>useEffect</code> cannot take advantage of fibers which are able to pause in order to let other higher priority work finish before rendering is resumed. This is because the effect is executed inside of <code>commitWork</code> which makes atomic changes to the rendering target to avoid UI inconsistencies. This is important to bear in mind lest one is tempted to perform computationally intensive, synchronous work inside a <code>useEffect</code> hook.</p><p>I hope this basic understanding of how <code>useEffect</code> works under the hood in mind helps you become more confident working with <code>useEffect</code> and avoid common pitfalls. It may also have encouraged you to pull away the curtain once in a while and take a look at the React source to deepen your understanding. The most difficult to understand parts of the code are often related to performance and other house-keeping, but you shouldn't let that shroud your understanding of the central pieces that are concerned with React’s core functionality.<br>Happy source reading!</p>","url":"http://localhost:2368/useeffect-under-the-hood/","canonical_url":null,"uuid":"d60ae843-3af2-413f-95a5-18f27348a961","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5e9d7c13fb708a9e1ad89877","reading_time":6}},{"node":{"id":"Ghost__Post__5e858c4e0a554e19673f4bf4","title":"Decouple from Redux using Hooks","slug":"decouple-from-redux-using-hooks","featured":false,"feature_image":"http://localhost:2368/content/images/2020/04/react-redux-decouple.png","excerpt":"We can use redux hooks to fully decouple our react components from redux or any state management solution. This leads to cleaner code that is easier to change.","custom_excerpt":"We can use redux hooks to fully decouple our react components from redux or any state management solution. This leads to cleaner code that is easier to change.","visibility":"public","created_at_pretty":"02 April, 2020","published_at_pretty":"03 April, 2020","updated_at_pretty":"03 April, 2020","created_at":"2020-04-02T06:55:10.000+00:00","published_at":"2020-04-03T14:35:44.000+00:00","updated_at":"2020-04-03T20:23:28.000+00:00","meta_title":"Decouple from Redux Using Hooks","meta_description":"We can use redux hooks to fully decouple our react components from redux or any state management solution. This leads to cleaner code that is easier to change.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Jan Bussieck","slug":"jan","bio":null,"profile_image":"//www.gravatar.com/avatar/e056f0b055ea37bd94fdc1664fca6e3d?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Jan Bussieck","slug":"jan","bio":null,"profile_image":"//www.gravatar.com/avatar/e056f0b055ea37bd94fdc1664fca6e3d?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"react","slug":"react","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"react","slug":"react","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"redux","slug":"redux","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"hooks","slug":"hooks","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Received wisdom in the react community holds that you should subdivide your\ncomponents into 'smart' containers and 'dumb', presentational components.\n\nThe rationale is to separate concerns. Logic and behavior such as data fetching,\nany interaction with the outside world, dispatching actions and other side\neffects go into our smart container and what our UI should look like as a\nfunction of the resulting data into our dumb component.\n\nThis idea leads to a pervasive pattern of creating container components solely\nfor the purpose of connecting a part of the component tree to the redux store.\nSo we end up with two components; one in a containers folder fetching data from\nthe store and passing down actions and the actual component in the components \nfolder. \n\nTo me, this quickly felt cumbersome and rigid, if I simply wanted a component to\nhave access to a slice of the store, I found myself having to create an\nintermediary container and changing a number of imports in other files that use\nthe component.\n\nI also stopped putting every bit of state into the redux store and instead took\nadvantage of react's new and improved context api to co-locate state\n[https://kentcdodds.com/blog/colocation] that is confined to a specific,\nwell-delineated part of the component tree. This raised questions such as\nwhether consuming context should also only happen inside containers. \n\nBesides, what are we really achieving by this kind of separation? Concerns about\ndata access still has us change a number of files in the component tree and the\nhierarchy of our UI seems to dictate which components should be containers (by\ndefault the top level one).\n\nWhile well-intentioned, the benefit of decoupling UI from state and behavior\ndoes not seem to warrant the overhead and complexity introduced by organizing\nfiles this way.\n\nLuckily, we have a perfect tool to decouple data and behavior from our\npresentational components...\n\nHooks!\n\nAnd wouldn't you know react-redux lets us consume its API only using hooks.\n\nLet's look at a small (and admittedly contrived) example. Say, we want to\nimplement a toggle button and keep the toggle state in the redux store, maybe it\nneeds to be available globally, toggling an app wide setting.\n\nThis is what such a component could look like using redux classico:\n\nimport React from \"react\";\nimport {connect} from \"react-redux\";\nimport {toggleAction} from \"./store/toggleActions\";\n\nconst Toggle = ({on, toggle}) => {\n  return (\n    <button onClick={toggle}>{on ? 'on' : 'off'}</button>\n  );\n};\n\nconst mapStateToProps = state => ({\n  on: state.toggle.on\n});\n\nconst mapDispatchToProps = {toggle: toggleAction};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Toggle);\n\n\nYes, we probably want this to be a container components wrapping a\npresentational component (e.g. a button) simply passing on and toggle down via\nprops, but for the sake of simplicity we're keeping everything in one component.\n\nNow let's refactor this to use the new redux hooks api:\n\nimport React from \"react\";\nimport {useDispatch, useSelector} from \"react-redux\";\nimport {toggleAction} from \"./store/toggleActions\";\n\nconst Toggle = () => {\n  const on = useSelector(state => state.toggle.on);\n  const dispatch = useDispatch();\n  return (\n    <button onClick={() => dispatch(toggleAction())}>{on ? 'on' : 'off'}</button>\n  );\n}\n\n\nNot much of an improvement, we reduced some boilerplate, but there is still a\nlot of redux code sitting in our component. \n\nThe beauty of hooks is how composable they are, we can just create a custom \nuseToggle hook:\n\nimport React from \"react\";\nimport {useDispatch, useSelector} from \"react-redux\";\nimport {toggleAction} from \"./store/toggleActions\";\n\nconst useToggle = () => {\n  const on = useSelector(state => state.toggle.on);\n  const dispatch = useDispatch();\n  const toggle = () =>  dispatch(toggleAction());\n  return [on, toggle];\n};\n\nconst Toggle = () => {\n  const [on, toggle] = useToggle();\n  return (\n    <button onClick={toggle()}>{on ? 'on' : 'off'}</button>\n  );\n};\n\nNow our component knows nothing about redux, we did not need to create a Toggle \ncontainer or some abstract HOC wrapping our button, we simply use a hook to\nencapsulates the data layer.\n\nThis way our components are also closed to modification, should we decide to\nemploy a different state management solution. Moving redux state into react\ncontext simply involves rewriting the hook (at least for consumers of the\ncontext):\n\nimport ToggleContext from './ToggleContext';\nconst useToggle = () => {\n  const {on, toggle} = useContext(ToggleContext);\n  return [on, toggle];\n};\n\nAs I already alluded to, another disadvantage of the container pattern is that\noften the top-level component ends up being the container that fetches a slice\nof state from the store and passes it down to its children as props.\n\nTake as an example a BookList container component that simply iterate over an\narray of books from the store and renders a BookItem in a list:\n\nimport React from \"react\";\nimport {connect} from \"react-redux\";\n\nconst BookItem = ({title, author}) => {\n  return (\n    <div>\n      <h1>{title}</h1>\n      <h2>{`by ${author}`}</h2>\n    </div>\n  );\n};\n\nconst BookList = ({books}) => {\n  return (\n    <ul>\n      {books.map(({book}) => {\n        return (\n          <li key={book.id}>\n            <BookItem {...book} />\n          <li>\n        );\n      })}\n    </ul>\n  )\n};\n\nconst mapStateToProps = state => ({\n  books: state.books.index\n});\n\nexport default connect(mapStateToProps)(BookList);\n\nA problem we might run into is that, if one book in the list is updated the\nentire list re-render which can quickly turn into an annoying performance issue.\nThat is why it's a good practice to provide data as close to where it is needed\nas possible. \n\nInstead of having to go in and add a BookItem container, we can just create a\ncustom hook.\n\nFirst BookList only receives an array of book ids, which presumably change less\nfrequently than an any particular book:\n\nimport React from \"react\";\nimport {connect} from \"react-redux\";\n\nconst BookList = ({bookIds}) => {\n  return (\n    <ul>\n      {bookIds.map(({bookId}) => {\n        return (\n          <li key={bookId}>\n            <BookItem id={bookId} />\n          <li>\n        )\n      })}\n    </ul>\n  );\n};\n\nconst mapStateToProps = state => ({\n  bookIds: state.books.ids\n});\n\nexport default connect(mapStateToProps)(BookList);\n\nThe BookItem then uses the book id to fetch its data from the store:\n\nimport React from \"react\";\nimport {useSelector} from \"react-redux\";\n\nconst BookItem = ({id}) => {\n  // we would normally pass a selector function here\n  const book = useSelector(state = state.booksById[id]);\n  return (\n    <div>\n      <h1>{book.title}</h1>\n      <h2>{`by ${book.author}`}</h2>\n    </div>\n  );\n};\n\n\nWe can neatly bundle that and even add the action creator for updating a book in\na custom useBook hook:\n\n// src/store/hooks.js\n\nconst useBook = (id) => {\n  const book = useSelector(getBook(id));\n  const dispatch = useDispatch();\n  const update = (...args) => dispatch(updateAction(id, ...args));\n  return [book, update];\n}\n\nDepending on how you structure your react redux projects you can include this\nhook as part of your redux-duck [https://github.com/erikras/ducks-modular-redux] \nor export it alongside actions and selectors inside your redux or store folder.\n\nIt is now easy to import a hook to consume data from our redux right where it is\nneeded profiting from the above mentioned performance gains.\n\nWhat is more, we effectively removed any trace of redux from our components,\ngranted we still need to wrap everything in a Provider, but the overall\nfootprint is vastly reduced. Now, wherever the tempestuous winds of the\njavascript ecosystem may carry you, you have a clean way of interacting with any\nstate management solution you choose in the future given it exposes hooks that\nyou can compose.\n\nIdeally hooks allow all our components to be dumb.","html":"<p>Received wisdom in the react community holds that you should subdivide your components into 'smart' containers and 'dumb', presentational components.</p><p>The rationale is to separate concerns. Logic and behavior such as data fetching, any interaction with the outside world, dispatching actions and other side effects go into our smart container and what our UI should look like as a function of the resulting data into our dumb component.</p><p>This idea leads to a pervasive pattern of creating container components solely for the purpose of connecting a part of the component tree to the redux store. So we end up with two components; one in a <code>containers</code> folder fetching data from the store and passing down actions and the actual component in the <code>components</code> folder. </p><p>To me, this quickly felt cumbersome and rigid, if I simply wanted a component to have access to a slice of the store, I found myself having to create an intermediary container and changing a number of imports in other files that use the component.</p><p>I also stopped putting every bit of state into the redux store and instead took advantage of react's new and improved context api to <a href=\"https://kentcdodds.com/blog/colocation\">co-locate state</a> that is confined to a specific, well-delineated part of the component tree. This raised questions such as whether consuming context should also only happen inside containers. </p><p>Besides, what are we really achieving by this kind of separation? Concerns about data access still has us change a number of files in the component tree and the hierarchy of our UI seems to dictate which components should be containers (by default the top level one).</p><p>While well-intentioned, the benefit of decoupling UI from state and behavior does not seem to warrant the overhead and complexity introduced by organizing files this way.</p><p>Luckily, we have a perfect tool to decouple data and behavior from our presentational components...</p><p>Hooks!</p><p>And wouldn't you know react-redux lets us consume its API only using hooks.</p><p>Let's look at a small (and admittedly contrived) example. Say, we want to implement a toggle button and keep the toggle state in the redux store, maybe it needs to be available globally, toggling an app wide setting.</p><p>This is what such a component could look like using redux classico:</p><pre><code class=\"language-javascript\">import React from \"react\";\nimport {connect} from \"react-redux\";\nimport {toggleAction} from \"./store/toggleActions\";\n\nconst Toggle = ({on, toggle}) =&gt; {\n  return (\n    &lt;button onClick={toggle}&gt;{on ? 'on' : 'off'}&lt;/button&gt;\n  );\n};\n\nconst mapStateToProps = state =&gt; ({\n  on: state.toggle.on\n});\n\nconst mapDispatchToProps = {toggle: toggleAction};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Toggle);\n</code></pre><p>Yes, we probably want this to be a container components wrapping a presentational component (e.g. a button) simply passing <code>on</code> and <code>toggle</code> down via props, but for the sake of simplicity we're keeping everything in one component.</p><p>Now let's refactor this to use the new redux hooks api:</p><pre><code class=\"language-javascript\">import React from \"react\";\nimport {useDispatch, useSelector} from \"react-redux\";\nimport {toggleAction} from \"./store/toggleActions\";\n\nconst Toggle = () =&gt; {\n  const on = useSelector(state =&gt; state.toggle.on);\n  const dispatch = useDispatch();\n  return (\n    &lt;button onClick={() =&gt; dispatch(toggleAction())}&gt;{on ? 'on' : 'off'}&lt;/button&gt;\n  );\n}\n</code></pre><p>Not much of an improvement, we reduced some boilerplate, but there is still a lot of redux code sitting in our component. </p><p>The beauty of hooks is how composable they are, we can just create a custom <code>useToggle</code> hook:</p><pre><code class=\"language-javascript\">import React from \"react\";\nimport {useDispatch, useSelector} from \"react-redux\";\nimport {toggleAction} from \"./store/toggleActions\";\n\nconst useToggle = () =&gt; {\n  const on = useSelector(state =&gt; state.toggle.on);\n  const dispatch = useDispatch();\n  const toggle = () =&gt;  dispatch(toggleAction());\n  return [on, toggle];\n};\n\nconst Toggle = () =&gt; {\n  const [on, toggle] = useToggle();\n  return (\n    &lt;button onClick={toggle()}&gt;{on ? 'on' : 'off'}&lt;/button&gt;\n  );\n};</code></pre><p>Now our component knows nothing about redux, we did not need to create a <code>Toggle</code> container or some abstract HOC wrapping our button, we simply use a hook to encapsulates the data layer.</p><p>This way our components are also closed to modification, should we decide to employ a different state management solution. Moving redux state into react context simply involves rewriting the hook (at least for consumers of the context):</p><pre><code class=\"language-javascript\">import ToggleContext from './ToggleContext';\nconst useToggle = () =&gt; {\n  const {on, toggle} = useContext(ToggleContext);\n  return [on, toggle];\n};</code></pre><p>As I already alluded to, another disadvantage of the container pattern is that often the top-level component ends up being the container that fetches a slice of state from the store and passes it down to its children as props.</p><p>Take as an example a <code>BookList</code> container component that simply iterate over an array of books from the store and renders a <code>BookItem</code> in a list:</p><pre><code class=\"language-javascript\">import React from \"react\";\nimport {connect} from \"react-redux\";\n\nconst BookItem = ({title, author}) =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;{title}&lt;/h1&gt;\n      &lt;h2&gt;{`by ${author}`}&lt;/h2&gt;\n    &lt;/div&gt;\n  );\n};\n\nconst BookList = ({books}) =&gt; {\n  return (\n    &lt;ul&gt;\n      {books.map(({book}) =&gt; {\n        return (\n          &lt;li key={book.id}&gt;\n            &lt;BookItem {...book} /&gt;\n          &lt;li&gt;\n        );\n      })}\n    &lt;/ul&gt;\n  )\n};\n\nconst mapStateToProps = state =&gt; ({\n  books: state.books.index\n});\n\nexport default connect(mapStateToProps)(BookList);</code></pre><p>A problem we might run into is that, if one book in the list is updated the entire list re-render which can quickly turn into an annoying performance issue. That is why it's a good practice to provide data as close to where it is needed as possible. </p><p>Instead of having to go in and add a <code>BookItem</code> container, we can just create a custom hook.</p><p>First <code>BookList</code> only receives an array of book ids, which presumably change less frequently than an any particular book:</p><pre><code class=\"language-javascript\">import React from \"react\";\nimport {connect} from \"react-redux\";\n\nconst BookList = ({bookIds}) =&gt; {\n  return (\n    &lt;ul&gt;\n      {bookIds.map(({bookId}) =&gt; {\n        return (\n          &lt;li key={bookId}&gt;\n            &lt;BookItem id={bookId} /&gt;\n          &lt;li&gt;\n        )\n      })}\n    &lt;/ul&gt;\n  );\n};\n\nconst mapStateToProps = state =&gt; ({\n  bookIds: state.books.ids\n});\n\nexport default connect(mapStateToProps)(BookList);</code></pre><p>The <code>BookItem</code> then uses the book id to fetch its data from the store:</p><pre><code class=\"language-javascript\">import React from \"react\";\nimport {useSelector} from \"react-redux\";\n\nconst BookItem = ({id}) =&gt; {\n  // we would normally pass a selector function here\n  const book = useSelector(state = state.booksById[id]);\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;{book.title}&lt;/h1&gt;\n      &lt;h2&gt;{`by ${book.author}`}&lt;/h2&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre><p>We can neatly bundle that and even add the action creator for updating a book in a custom <code>useBook</code> hook:</p><pre><code class=\"language-javascript\">// src/store/hooks.js\n\nconst useBook = (id) =&gt; {\n  const book = useSelector(getBook(id));\n  const dispatch = useDispatch();\n  const update = (...args) =&gt; dispatch(updateAction(id, ...args));\n  return [book, update];\n}</code></pre><p>Depending on how you structure your react redux projects you can include this hook as part of your <a href=\"https://github.com/erikras/ducks-modular-redux\">redux-duck</a> or export it alongside actions and selectors inside your <code>redux</code> or <code>store</code> folder.</p><p>It is now easy to import a hook to consume data from our redux right where it is needed profiting from the above mentioned performance gains.</p><p>What is more, we effectively removed any trace of redux from our components, granted we still need to wrap everything in a <code>Provider</code>, but the overall footprint is vastly reduced. Now, wherever the tempestuous winds of the javascript ecosystem may carry you, you have a clean way of interacting with any state management solution you choose in the future given it exposes hooks that you can compose.</p><p>Ideally hooks allow all our components to be dumb.</p>","url":"http://localhost:2368/decouple-from-redux-using-hooks/","canonical_url":null,"uuid":"b6b74a4c-0336-435f-af43-f5b1fd829ae5","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5e858c4e0a554e19673f4bf4","reading_time":5}}]}},"pageContext":{"slug":"hooks","limit":12,"skip":0,"numberOfPages":1,"humanPageNumber":1,"prevPageNumber":null,"nextPageNumber":null,"previousPagePath":null,"nextPagePath":null}}}