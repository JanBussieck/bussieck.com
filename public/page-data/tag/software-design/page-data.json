{"componentChunkName":"component---src-templates-tag-js","path":"/tag/software-design/","result":{"data":{"ghostTag":{"slug":"software-design","name":"Software Design","visibility":"public","feature_image":null,"description":null,"meta_title":null,"meta_description":null},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__5e73dfb21baf0e7fa30dd914","title":"'On Writing Software Well' II","slug":"on-writing-software-well-part-ii-callback","featured":true,"feature_image":"https://images.unsplash.com/photo-1556761175-b413da4baf72?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ","excerpt":"Callbacks vs. Listeners\nWe walk through how DHH employs callbacks in Basecamp to send mentions and I offer alternative approach moving code into the controller and using listeners for higher decoupling.","custom_excerpt":"Callbacks vs. Listeners\nWe walk through how DHH employs callbacks in Basecamp to send mentions and I offer alternative approach moving code into the controller and using listeners for higher decoupling.","visibility":"public","created_at_pretty":"19 March, 2020","published_at_pretty":"19 March, 2020","updated_at_pretty":"22 March, 2020","created_at":"2020-03-19T21:10:10.000+00:00","published_at":"2020-03-19T21:24:28.000+00:00","updated_at":"2020-03-22T12:18:34.000+00:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Jan Bussieck","slug":"jan","bio":null,"profile_image":"//www.gravatar.com/avatar/e056f0b055ea37bd94fdc1664fca6e3d?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Jan Bussieck","slug":"jan","bio":null,"profile_image":"//www.gravatar.com/avatar/e056f0b055ea37bd94fdc1664fca6e3d?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Ruby on Rails","slug":"ruby-on-rails","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Ruby on Rails","slug":"ruby-on-rails","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Software Design","slug":"software-design","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Tech","slug":"tech","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Callbacks vs. Listeners\nDHH remarks that he is a big fan of callbacks since they allow you to move a lot\nof incidental complexity off to the side while the rest of the code can pretend\nto be on a simple, default path shielding the programmer from a lot of the\ncognitive load that lives in callbacks instead.\n\nTo see what that means in practice, we are going to trace the mentions feature\nin Basecamp all the way down and pay attention to how callbacks are used to that\nend.\n\nThe entry point is the create action of the messages controller, which simply\nrecords a new message on a bucket (a bucket is an abstraction used to group\ncertain entities, which will be explained in future episodes). The new_message \nmethod in turn simply instantiates a message, note that logic pertaining to the\ncreation of mentions or actual recordings is missing from the controller.\n\nclass MessagesController < ApplicationController\n...\n  def create\n    @recording = @bucket.record new_message,\n      parent: @parent_recording,\n      status: status_param,\n      subscribers: find_subscribers,\n      category: find_category\n\n    ...\n  end\n  ...\n  def new_message\n    Message.new params.require(:message).permit(:subject, :content)\n  end\n...\nend\n\n\nA mention is a model joining a mentioner and mentionee to a specific recording:\n\nclass Mention < ActiveRecord::Base\n  ...\n  belongs_to: :recording\n\n  belongs_to: mentionee, class_name: 'Person', inverse_of: :mentions\n  belongs_to: mentioner, class_name: 'Person'\n  ...\n  after_commit :deliver, unless: -> { mentioner == mentionee }, on: [:create, :update]\nend\n\n\nMentions are a simple concern which orchestrates when mentions are to be\nscheduled.\n\nmodule Recording::Mentions\n  extend ActiveSupport::Concern\n\n  included do\n    has_many :mentions\n    after_save :remember_to_eavesdrop\n    after_commit :eavesdrop_for_mentions, on: %i[ create update ], if: :eavesdropping?\n  end\n  ...\n  private\n  \n  def remember_to_eavesdrop\n    @eavesdropping = active_or_archived_recordable_changed? || draft_became_active?\n  end\n\n  def eavesdropping?\n    @eavesdropping && !Mention::Eavesdropper.suppressed? && has_mentions? \n  end\n\n  def eavesdrop_for_mentions\n    Mention::EavesdroppingJob.perform_later self, mentioner: Current.person\n  end\nend\n\n\nDHH points out a trick to track dirty attributes, circumventing a problem that\nmany Rails developers have also run into; when you run an after_commit callback\nyou can no longer access to which attributes changed invoking neither \nchanged_attributes nor the _changed? methods, since they only persist within a\ndatabase transaction.\n\nWe simply check before the transaction is committed in an after_save callback\nwhich attributes changed, make a note of it in an instance variable so that we\ncan access the information later (e.g. in the after_commit callback).\n\nHere, remember_to_eavesdrop records whether the content of the recordable record\nactually changed or whether a recordable which might contain mentions became\nactive before we scan for mentions.\n\nThe eavesdropping? query method simply checks whether the instance variable is\nset, that mentions exists and that the eavesdropping callback has not been\ndisabled via suppress. To the last point, DDH explains that while callbacks are\nsupposed to contain code that should run by default, it might sometimes be\nnecessary to disable them.\n\nFinally, after checking whether we should perform any work and scan for\nmentions, the actual work is delegated to a job via eavesdrop_for_mentions, the\njob simply instantiates an instance of Mention::Eavesdropper which creates the\nactual mentions. Also, note how the method Current, a class that allows global,\nper-request storage of attributes, is used to pass the current user as mentioner\nto the job.\n\nclass Mention::EavesdroppingJob < ApplicationJob\n  queue_as :background\n\n  def perform(recording, mentioner)\n    Current.set(account: recording.account) do\n      Mention::EavesDropper.new(recording, mentioner).create_mentions\n    end\n  end\nend\n\n\nThe EavesDropper in turn invokes a scanner that finds mentionees and creates\nmentions.\n\nclass Mention::Eavesdropper\n  extend Suppressible\n  ...\n  def create_mentions\n    recording.with_lock do\n      mentionees.each do |mentionee, callsign|\n        create_mention mentionee, callsign\n      end\n    end\n  end\nend\n\n\nThat is it, we moved the ancillary concern of creating mentions off to the side,\nby handling it in callbacks as response to certain life cycle events of our\nmodel as opposed to the 'main path' of our code inside the controller action. A\ndeveloper interested in the main path i.e. creating messages is not confronted\nwith the complexity of creating mentions right away. While it is true that this\nreduces some cognitive load in that specific case, it comes at non-negligible\ncost.\nNote how we had to trace the feature of creating mentions in response to a\nchange to a recordable record all the way from the controller, through the\nmodel's life cycle methods to a job and finally a service creating the mentions.\nAlong the way we are given hints that this level of coupling is fraught with\nsome amount amount of complication.\n\nTracking dirty attributes\nFirst off, we need intricate knowledge about Rails life cycle methods in order\nto be able to track changes to a recording and know whether we should even check\nfor mentions. I need to be cognizant of database transaction and how they relate\nto callbacks to even become aware of how to track model changes in after_commit.\nTalk about incidental complexity.\n\nChecking for suppression in callbacks\nSecondly, apparently, there are use cases where the client (whoever is\ninitiating those model updates) might not want to listen for mentions, maybe I\nam seeding data or going through an admin API that I don't want to trigger\nsending emails. Quite plausible. In those cases, I need to check whether\ncreating mention eavesdroppers has explicitly been suppressed. The problems\nintroduced by this sort of coupling have been addressed in this post. But it\nagain strikes me as very counterintuitive and error-prone to reach into a\ncompletely different class, whose internal state has been modified elsewhere in\norder to decide whether to run a callback or not.\n\nUsing Current to store request-wide state\nFinally, a problem that results from handling these types of interactions deep\ndown in active record models is that I still need information from the\ncontroller. In this case, a global object is used to register that information\nmaking it globally accessible in the entire application. That should be the\nclearest indication that I might be performing work in a class that has to know\ntoo much in order to perform it and hence might be the wrong place to do it.\n\nThe controller as mediator\nThat's enough for criticisms. I think the highlighted problems all indicate that\nwe shouldn't know what the we are trying to know inside the callback, because we\nare too far removed from where those decisions occur; the controller.\n\nI have always thought of the controller, more specifically a controller action,\nas a mediator [https://en.wikipedia.org/wiki/Mediator_pattern] encapsulating\nknowledge about a particular use case and deciding which models need to talk to\nwhich and what they need to know to accomplish their particular tasks. The\ncontroller orchestrates, passes on information and creates side effects, much in\nthe vein of Gary Bernhardt's functional core / imperative shell\n[https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell]\n.\n\nAt speqtor.com [http://speqtor.com], we have a similar feature to Basecamp's\nmentions where certain updates to models create notifications for different\nusers subscribed to that model.\n\nA typical controller action looks like this:\n\ndef update\n  load_criterion\n  build_criterion\n  authorize_criterion\n\n  subscribe_listeners(@criterion)\n\n  save_criterion\n\n  decorate_criterion\n  render_criterion\nend\n\n\nWe like sticking to the same structure in every controller which makes them easy\nto understand and to spot where interesting things are happening (See the\nexcellent Growing Rails Applications in Practice\n[https://leanpub.com/growing-rails]). Here, we are updating a criterion that\nindicates how complex a project is going to be. In this specific use case, a\nuser directly interacts with our web app, as opposed to an importer job or the\nrails console. In this context we want a number of side effects to happen as a\nresult of certain model events. This is achieved by registering event listeners,\nwhich in turn decide what is supposed to happen as a result of those changes.\n\nIn our example, we want to listen to successful updates in order to notify other\nusers.\n\nThis happens inside the SubscribesListeners concern:\n\ndef subscribe_notification_listener(options = {})\n  with_load_error_guard do\n    listener_class = options[:notification_listener_class] || infer_listener\n    listener = listener_class.new\n\n    listener.current_user = current_user\n    listener.changes = subscription_target.changes.transform_values do |val|\n      val.map(&:to_s)\n    end\n\n    subscription_target.subscribe listener, async: true\n  end\nend\n\n\nHere, we are instantiating the listener class, pass in the information it needs,\ni.e. model changes and the current user and subscribe it to the target model (in\nthis case the criterion). Often we add other information available in the\ncontroller, such as the scope of the current project or user permissions. The\nlistener, in turn, simply creates the notification.\n\nSimple enough.\n\nHow are the above problems solved here?\n\nRegarding dirty attribute tracking; since we haven't persisted the model yet, we\ncan still access model changes though the attributes api, when the model is\nsaved and the database transaction completes, the listener is merely notified of\nits success or failure.\n\nAs we are still inside the controller context we can also pass any information\nsuch as the current user to the listener without having to awkwardly store it in\na global Current.\n\nLastly, the listener is maximally decoupled, we have to explicitly opt into\ncreating notifications depending on the current use case, as opposed to\nanticipating every use case by checking related models for suppression.\n\nAn additional benefit is that, we can now easily background the listener without\nhaving to worry  about implicit state in the form of model suppression or \nCurrent registries.\n\nSo what should callbacks be used for?\n\nI am not a big fan of hard and fast rules in software design, but sometimes it's\nprudent to have certain guidelines to stick to unless there is a very good\nreason for violating them.\n\nOne of them is that callbacks should only deal with immediate model concerns,\nwhich are in declining order of popularity:\n\n 1. Maintaining data integrity and mutating the model into a valid state,\n    examples are normalizing or splitting attributes.\n 2. Mutate a closely associated model, for instance counter caches in a\n    one-to-many association.\n 3. Small side effects for related or derived data such as busting caches.","html":"<h2 id=\"callbacks-vs-listeners\">Callbacks vs. Listeners</h2><p>DHH remarks that he is a big fan of callbacks since they allow you to move a lot of incidental complexity off to the side while the rest of the code can pretend to be on a simple, default path shielding the programmer from a lot of the cognitive load that lives in callbacks instead.</p><p>To see what that means in practice, we are going to trace the mentions feature in Basecamp all the way down and pay attention to how callbacks are used to that end.</p><p>The entry point is the create action of the messages controller, which simply records a new message on a bucket (a bucket is an abstraction used to group certain entities, which will be explained in future episodes). The <code>new_message</code> method in turn simply instantiates a message, note that logic pertaining to the creation of mentions or actual recordings is missing from the controller.</p><pre><code class=\"language-ruby\">class MessagesController &lt; ApplicationController\n...\n  def create\n    @recording = @bucket.record new_message,\n      parent: @parent_recording,\n      status: status_param,\n      subscribers: find_subscribers,\n      category: find_category\n\n    ...\n  end\n  ...\n  def new_message\n    Message.new params.require(:message).permit(:subject, :content)\n  end\n...\nend\n</code></pre><p>A mention is a model joining a mentioner and mentionee to a specific recording:</p><pre><code class=\"language-ruby\">class Mention &lt; ActiveRecord::Base\n  ...\n  belongs_to: :recording\n\n  belongs_to: mentionee, class_name: 'Person', inverse_of: :mentions\n  belongs_to: mentioner, class_name: 'Person'\n  ...\n  after_commit :deliver, unless: -&gt; { mentioner == mentionee }, on: [:create, :update]\nend\n</code></pre><p>Mentions are a simple concern which orchestrates when mentions are to be scheduled.</p><pre><code class=\"language-ruby\">module Recording::Mentions\n  extend ActiveSupport::Concern\n\n  included do\n    has_many :mentions\n    after_save :remember_to_eavesdrop\n    after_commit :eavesdrop_for_mentions, on: %i[ create update ], if: :eavesdropping?\n  end\n  ...\n  private\n  \n  def remember_to_eavesdrop\n    @eavesdropping = active_or_archived_recordable_changed? || draft_became_active?\n  end\n\n  def eavesdropping?\n    @eavesdropping &amp;&amp; !Mention::Eavesdropper.suppressed? &amp;&amp; has_mentions? \n  end\n\n  def eavesdrop_for_mentions\n    Mention::EavesdroppingJob.perform_later self, mentioner: Current.person\n  end\nend\n</code></pre><p>DHH points out a trick to track dirty attributes, circumventing a problem that many Rails developers have also run into; when you run an <code>after_commit</code> callback you can no longer access to which attributes changed invoking neither <code>changed_attributes</code> nor the <code>_changed?</code> methods, since they only persist within a database transaction.</p><p>We simply check before the transaction is committed in an <code>after_save</code> callback which attributes changed, make a note of it in an instance variable so that we can access the information later (e.g. in the <code>after_commit</code> callback).</p><p>Here, <code>remember_to_eavesdrop</code> records whether the content of the recordable record actually changed or whether a recordable which might contain mentions became active before we scan for mentions.</p><p>The <code>eavesdropping?</code> query method simply checks whether the instance variable is set, that mentions exists and that the eavesdropping callback has not been disabled via <code>suppress</code>. To the last point, DDH explains that while callbacks are supposed to contain code that should run by default, it might sometimes be necessary to disable them.</p><p>Finally, after checking whether we should perform any work and scan for mentions, the actual work is delegated to a job via <code>eavesdrop_for_mentions</code>, the job simply instantiates an instance of <code>Mention::Eavesdropper</code> which creates the actual mentions. Also, note how the method <code>Current,</code> a class that allows global, per-request storage of attributes, is used to pass the current user as mentioner to the job.</p><pre><code class=\"language-ruby\">class Mention::EavesdroppingJob &lt; ApplicationJob\n  queue_as :background\n\n  def perform(recording, mentioner)\n    Current.set(account: recording.account) do\n      Mention::EavesDropper.new(recording, mentioner).create_mentions\n    end\n  end\nend\n</code></pre><p>The <code>EavesDropper</code> in turn invokes a scanner that finds mentionees and creates mentions.</p><pre><code class=\"language-ruby\">class Mention::Eavesdropper\n  extend Suppressible\n  ...\n  def create_mentions\n    recording.with_lock do\n      mentionees.each do |mentionee, callsign|\n        create_mention mentionee, callsign\n      end\n    end\n  end\nend\n</code></pre><p>That is it, we moved the ancillary concern of creating mentions off to the side, by handling it in callbacks as response to certain life cycle events of our model as opposed to the 'main path' of our code inside the controller action. A developer interested in the main path i.e. creating messages is not confronted with the complexity of creating mentions right away. While it is true that this reduces some cognitive load in that specific case, it comes at non-negligible cost.<br>Note how we had to trace the feature of creating mentions in response to a change to a recordable record all the way from the controller, through the model's life cycle methods to a job and finally a service creating the mentions. Along the way we are given hints that this level of coupling is fraught with some amount amount of complication.</p><h3 id=\"tracking-dirty-attributes\">Tracking dirty attributes</h3><p>First off, we need intricate knowledge about Rails life cycle methods in order to be able to track changes to a recording and know whether we should even check for mentions. I need to be cognizant of database transaction and how they relate to callbacks to even become aware of how to track model changes in <code>after_commit</code>. Talk about incidental complexity.</p><h3 id=\"checking-for-suppression-in-callbacks\">Checking for suppression in callbacks</h3><p>Secondly, apparently, there are use cases where the client (whoever is initiating those model updates) might not want to listen for mentions, maybe I am seeding data or going through an admin API that I don't want to trigger sending emails. Quite plausible. In those cases, I need to check whether creating mention eavesdroppers has explicitly been suppressed. The problems introduced by this sort of coupling have been addressed in this post. But it again strikes me as very counterintuitive and error-prone to reach into a completely different class, whose internal state has been modified elsewhere in order to decide whether to run a callback or not.</p><h3 id=\"using-current-to-store-request-wide-state\">Using <code>Current</code> to store request-wide state</h3><p>Finally, a problem that results from handling these types of interactions deep down in active record models is that I still need information from the controller. In this case, a global object is used to register that information making it globally accessible in the entire application. That should be the clearest indication that I might be performing work in a class that has to know too much in order to perform it and hence might be the wrong place to do it.</p><h3 id=\"the-controller-as-mediator\">The controller as mediator</h3><p>That's enough for criticisms. I think the highlighted problems all indicate that we shouldn't know what the we are trying to know inside the callback, because we are too far removed from where those decisions occur; the controller.</p><p>I have always thought of the controller, more specifically a controller action, as a <a href=\"https://en.wikipedia.org/wiki/Mediator_pattern\">mediator</a> encapsulating knowledge about a particular use case and deciding which models need to talk to which and what they need to know to accomplish their particular tasks. The controller orchestrates, passes on information and creates side effects, much in the vein of Gary Bernhardt's <a href=\"https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell\">functional core / imperative shell</a>.</p><p>At <a href=\"http://speqtor.com\">speqtor.com</a>, we have a similar feature to Basecamp's mentions where certain updates to models create notifications for different users subscribed to that model.</p><p>A typical controller action looks like this:</p><pre><code class=\"language-ruby\">def update\n  load_criterion\n  build_criterion\n  authorize_criterion\n\n  subscribe_listeners(@criterion)\n\n  save_criterion\n\n  decorate_criterion\n  render_criterion\nend\n</code></pre><p>We like sticking to the same structure in every controller which makes them easy to understand and to spot where interesting things are happening (See the excellent <a href=\"https://leanpub.com/growing-rails\">Growing Rails Applications in Practice</a>). Here, we are updating a criterion that indicates how complex a project is going to be. In this specific use case, a user directly interacts with our web app, as opposed to an importer job or the rails console. In this context we want a number of side effects to happen as a result of certain model events. This is achieved by registering event listeners, which in turn decide what is supposed to happen as a result of those changes.</p><p>In our example, we want to listen to successful updates in order to notify other users.</p><p>This happens inside the <code>SubscribesListeners</code> concern:</p><pre><code class=\"language-ruby\">def subscribe_notification_listener(options = {})\n  with_load_error_guard do\n    listener_class = options[:notification_listener_class] || infer_listener\n    listener = listener_class.new\n\n    listener.current_user = current_user\n    listener.changes = subscription_target.changes.transform_values do |val|\n      val.map(&amp;:to_s)\n    end\n\n    subscription_target.subscribe listener, async: true\n  end\nend\n</code></pre><p>Here, we are instantiating the listener class, pass in the information it needs, i.e. model changes and the current user and subscribe it to the target model (in this case the criterion). Often we add other information available in the controller, such as the scope of the current project or user permissions. The listener, in turn, simply creates the notification.</p><p>Simple enough.</p><p>How are the above problems solved here?</p><p>Regarding dirty attribute tracking; since we haven't persisted the model yet, we can still access model changes though the attributes api, when the model is saved and the database transaction completes, the listener is merely notified of its success or failure.</p><p>As we are still inside the controller context we can also pass any information such as the current user to the listener without having to awkwardly store it in a global <code>Current</code>.</p><p>Lastly, the listener is maximally decoupled, we have to explicitly opt into creating notifications depending on the current use case, as opposed to anticipating every use case by checking related models for suppression.</p><p>An additional benefit is that, we can now easily background the listener without having to worry  about implicit state in the form of model suppression or <code>Current</code> registries.</p><p>So what should callbacks be used for?</p><p>I am not a big fan of hard and fast rules in software design, but sometimes it's prudent to have certain guidelines to stick to unless there is a very good reason for violating them.</p><p>One of them is that callbacks should only deal with immediate model concerns, which are in declining order of popularity:</p><ol><li>Maintaining data integrity and mutating the model into a valid state, examples are normalizing or splitting attributes.</li><li>Mutate a closely associated model, for instance counter caches in a one-to-many association.</li><li>Small side effects for related or derived data such as busting caches.</li></ol>","url":"http://localhost:2368/on-writing-software-well-part-ii-callback/","canonical_url":null,"uuid":"77cf93ca-42f0-44a2-b986-3cb07cf9f3a5","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5e73dfb21baf0e7fa30dd914","reading_time":6}},{"node":{"id":"Ghost__Post__5e7383d91baf0e7fa30dd890","title":"'On Writing Software Well' I","slug":"on-writing-software-well-part-1","featured":false,"feature_image":"https://images.unsplash.com/photo-1556742044-3c52d6e88c62?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ","excerpt":"Comments and Extracting Rails Features\n\nWe're looking at DHH's series to talk about software design using real world software with alls its trade-offs, necessary messiness and complexity so neatly omitted in your standard textbook toy examples.","custom_excerpt":"Comments and Extracting Rails Features\n\nWe're looking at DHH's series to talk about software design using real world software with alls its trade-offs, necessary messiness and complexity so neatly omitted in your standard textbook toy examples.","visibility":"public","created_at_pretty":"19 March, 2020","published_at_pretty":"19 March, 2020","updated_at_pretty":"20 March, 2020","created_at":"2020-03-19T14:38:17.000+00:00","published_at":"2020-03-19T15:57:00.000+00:00","updated_at":"2020-03-20T14:58:59.000+00:00","meta_title":"Ruby on Rails: Writing Software Well Part 1","meta_description":"Part 1 deals with expressive constants and code colocation and the dos and donts of using exception as control flow.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Jan Bussieck","slug":"jan","bio":null,"profile_image":"//www.gravatar.com/avatar/e056f0b055ea37bd94fdc1664fca6e3d?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Jan Bussieck","slug":"jan","bio":null,"profile_image":"//www.gravatar.com/avatar/e056f0b055ea37bd94fdc1664fca6e3d?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Ruby on Rails","slug":"ruby-on-rails","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Ruby on Rails","slug":"ruby-on-rails","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Software Design","slug":"software-design","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Tech","slug":"tech","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Comments and Extracting Rails Features \nDHH has drawn back the curtain on how Basecamp writes software in a video\nseries, tentatively titled 'On Writing Software (well?)', I find it highly\ninstructive and valuable to talk about software design using real world software\nwith alls its trade-offs, necessary messiness and complexity so neatly omitted\nin your standard textbook toy examples.\n\nWhile I do lay out the contents of each episode, this is not a series plain\ntranscript, but rather a way for me to engage with the challenges raised in DHHs\nexamples, add my own thoughts and, at times, contrast his approach with the one\nwe took for speqtor.com [http://speqtor.com] sharing examples from our code\nbase.\n\nEpisode 1\nWhile Code comments are sometimes necessary to explain certain decisions or\ntrade-offs that aren't obvious from the code, more often than not comments are a\nkind of code smell. \n\nYou should ask yourself why am I writing this comment? How could the code itself\nbe clearer and not need this comment?\n\nEvery developer is familiar with arcane, outdated comments in the midst of\nseemingly unrelated code, because the related code had been deleted. Another\nadvantage of self-explanatory code apart from just being clearer (by definition)\nis that it preempts the problem of code and its explanation getting out of sync.\n\ndef remove_inaccessible_records\n  # 30s of forgiveness in case of accidental removal\n  unless person.destroyed? || bucket.destroyed\n    Person::RemoveInaccessibleRecordJob.set(wait: 30.seconds).perform_later(person, bucket)\n  end\nend\n\nThe Basecamp codebase includes a method to remove all inaccessible records after\na user has been deleting, because restoring a user's objects in the bucket is\ncumbersome a 30 second grace period was added in case a user is accidentally\nremoved.\n\nA comment explains not the control flow, but the configuration of the job.\n\nWe could simply add an explanatory variable elucidating the magic value of 30\nseconds and hinting at its purpose.\n\ndef remove_inaccessible_records\n  grace_period_removing_inaccessible_records = 30.seconds\n\n  unless person.destroyed? || bucket.destroyed?\n    Person::RemoveInaccessibleRecordJob.set(wait: 30.seconds).perform_later(person, bucket)\n  end\nend\n\nHowever, the value does not vary, so why store it in a variable, it should be a\nconstant. But instead of defining it at the top of the file, as we idiomatically\nwould for public constants in ruby, we should prefer colocating related code and\nmaking the constant private.\n\nprivate\nGRACE_PERIOD_REMOVING_INACCESSIBLE_RECORDS = 30.seconds\n\ndef remove_inaccessible_records\n  unless person.destroyed? || bucket.destroyed?\n  Person::RemoveInaccessibleRecordJob.set(\n    wait: GRACE_PERIOD_REMOVING_INACCESSIBLE_RECORDS\n  ).perform_later(person, bucket)\n  end\nend\n\nI would go a step further and separate configuration from my app code,\nespecially since often you might want to have different values for different\nenvironments, for instance in testing environment you might want the job to\nexecute immediately and not wait 30 seconds.\n\nMore importantly, I have a central place to go looking for configuration options\nin my applications and they're not scattered across my source code. In Speqtor,\nfor example, we only send out a notification if no new notifications for a user\nwere scheduled within a certain cool down period, so as not to clog up their\ninbox.\n\nThe config options are defined in config/notifications.yml\n\nproduction:\n  cool_off_period_in_minutes: 20\ndevelopment:\n  cool_off_period_in_minutes: 0.2\ntest:\n  cool_off_period_in_minutes: 0\n\nand included it in application.rb  under the rails namespace config.x for\ncustom\nconfiguration.\n[https://guides.rubyonrails.org/configuring.html#custom-configuration]\n\nconfig.x.notification = config_for(:notification)\n\nBack to DHH, who show us an example of how some of his refactorings lead to new\nfeatures in Rails. In Basecamp there is a join model for granting users\nadministrative access to certain resource and a helper method grant that accepts\na person argument and creates an entry for the person in the join model, if an\nentry already exists it simply returns the person record.\n\nWhat might jump out at you about this method is that it commits the sin of using\nan exception for controlling flow. The dual offense of using framework\nexceptions in your code is that it also mixes two different levels of\nabstraction, in this case the top-level ActiveRecord API and constants from the\nbowels of ActiveRecord.\n\nmodule Account::Administered\n  extend ActiveSupport::Concern\n\n  included do\n    has_many :administratorships\n\n    def grant(person)\n\t  create! person: person\n        rescue ActiveRecord::RecordNotUnique\n        # don't worry about dupes. Treat them the same as successful creation\n        where(person: person).take\n      end\n    end\n  end\nend\n\nThe reason we are avoiding ActiveRecord's find_or_initialize_by here is that we\nmight end up with stale reads, as find_or_initialize_by first checks whether a\nrecord with the attributes exists using a where query and returns it if it does\nor else creates one with those attributes.\n\nIn applications with high load this could lead to the result returned by the \nwhere clause to being outdated, in which case the create might fail, because the\nrecord has already been created in the interim. Hence, we are first attempting\nto create the record and if that fails because it already exists we simply\nreturn it.\n\nSo what we actually want is create_of_find_by(person: person) which encapsulate\nthis behavior and simplifies this code to a mere delegation:\n\ndef grant(person)\n  create_or_find_by(person: person)\nend\n\nAnd indeed, this method has made it into Rails 6 and it's arguably what \nfind_or_create_by should have been from the beginning.\n\nJust a note on the topic of exceptions as a flow control; in this instance, I\nthink it is perfectly fine to do so (and in fact the Rails method does just that\n[https://github.com/rails/rails/blob/f675cb30ce813a99b52b139a93e048330922fd9a/activerecord/lib/active_record/relation.rb#L218]\n), because we are relying on the database's mechanism for ensuring data\nconsistency and simply pass the exception through to the caller. We could not\nhave performed this check without dealing with the database exception, since\nthis is the only interface offered to our application code.","html":"<h2 id=\"comments-and-extracting-rails-features\">Comments and Extracting Rails Features </h2><p>DHH has drawn back the curtain on how Basecamp writes software in a video series, tentatively titled 'On Writing Software (well?)', I find it highly instructive and valuable to talk about software design using real world software with alls its trade-offs, necessary messiness and complexity so neatly omitted in your standard textbook toy examples.</p><p>While I do lay out the contents of each episode, this is not a series plain transcript, but rather a way for me to engage with the challenges raised in DHHs examples, add my own thoughts and, at times, contrast his approach with the one we took for <a href=\"http://speqtor.com\">speqtor.com</a> sharing examples from our code base.</p><h2 id=\"episode-1\">Episode 1</h2><p>While Code comments are sometimes necessary to explain certain decisions or trade-offs that aren't obvious from the code, more often than not comments are a kind of code smell. </p><p>You should ask yourself <em>why</em> am I writing this comment? How could the code itself be clearer and not need this comment?</p><p>Every developer is familiar with arcane, outdated comments in the midst of seemingly unrelated code, because the related code had been deleted. Another advantage of self-explanatory code apart from just being clearer (by definition) is that it preempts the problem of code and its explanation getting out of sync.</p><pre><code class=\"language-ruby\">def remove_inaccessible_records\n  # 30s of forgiveness in case of accidental removal\n  unless person.destroyed? || bucket.destroyed\n    Person::RemoveInaccessibleRecordJob.set(wait: 30.seconds).perform_later(person, bucket)\n  end\nend</code></pre><p>The Basecamp codebase includes a method to remove all inaccessible records after a user has been deleting, because restoring a user's objects in the bucket is cumbersome a 30 second grace period was added in case a user is accidentally removed.</p><p>A comment explains not the control flow, but the configuration of the job.</p><p>We could simply add an <em>explanatory variable</em> elucidating the magic value of 30 seconds and hinting at its purpose.</p><pre><code class=\"language-ruby\">def remove_inaccessible_records\n  grace_period_removing_inaccessible_records = 30.seconds\n\n  unless person.destroyed? || bucket.destroyed?\n    Person::RemoveInaccessibleRecordJob.set(wait: 30.seconds).perform_later(person, bucket)\n  end\nend</code></pre><p>However, the value does not vary, so why store it in a variable, it should be a constant. But instead of defining it at the top of the file, as we idiomatically would for public constants in ruby, we should prefer colocating related code and making the constant private.</p><pre><code class=\"language-ruby\">private\nGRACE_PERIOD_REMOVING_INACCESSIBLE_RECORDS = 30.seconds\n\ndef remove_inaccessible_records\n  unless person.destroyed? || bucket.destroyed?\n  Person::RemoveInaccessibleRecordJob.set(\n    wait: GRACE_PERIOD_REMOVING_INACCESSIBLE_RECORDS\n  ).perform_later(person, bucket)\n  end\nend</code></pre><p>I would go a step further and separate configuration from my app code, especially since often you might want to have different values for different environments, for instance in testing environment you might want the job to execute immediately and not wait 30 seconds.</p><p>More importantly, I have a central place to go looking for configuration options in my applications and they're not scattered across my source code. In Speqtor, for example, we only send out a notification if no new notifications for a user were scheduled within a certain cool down period, so as not to clog up their inbox.</p><p>The config options are defined in <code>config/notifications.yml</code></p><pre><code class=\"language-ruby\">production:\n  cool_off_period_in_minutes: 20\ndevelopment:\n  cool_off_period_in_minutes: 0.2\ntest:\n  cool_off_period_in_minutes: 0</code></pre><p>and included it in application.rb  under the rails namespace config.x <a href=\"https://guides.rubyonrails.org/configuring.html#custom-configuration\" rel=\"noopener noreferrer\">for custom configuration.</a></p><p><code>config.x.notification = config_for(:notification)</code></p><p>Back to DHH, who show us an example of how some of his refactorings lead to new features in Rails. In Basecamp there is a join model for granting users administrative access to certain resource and a helper method <code>grant</code> that accepts a <code>person</code> argument and creates an entry for the person in the join model, if an entry already exists it simply returns the person record.</p><p>What might jump out at you about this method is that it commits the sin of using an exception for controlling flow. The dual offense of using framework exceptions in your code is that it also mixes two different levels of abstraction, in this case the top-level ActiveRecord API and constants from the bowels of ActiveRecord.</p><pre><code class=\"language-ruby\">module Account::Administered\n  extend ActiveSupport::Concern\n\n  included do\n    has_many :administratorships\n\n    def grant(person)\n\t  create! person: person\n        rescue ActiveRecord::RecordNotUnique\n        # don't worry about dupes. Treat them the same as successful creation\n        where(person: person).take\n      end\n    end\n  end\nend</code></pre><p>The reason we are avoiding ActiveRecord's <code>find_or_initialize_by</code> here is that we might end up with stale reads, as <code>find_or_initialize_by</code>  first checks whether a record with the attributes exists using a <code>where</code> query and returns it if it does or else creates one with those attributes.</p><p>In applications with high load this could lead to the result returned by the <code>where</code> clause to being outdated, in which case the create might fail, because the record has already been created in the interim. Hence, we are first attempting to create the record and if that fails because it already exists we simply return it.</p><p>So what we actually want is <code>create_of_find_by(person: person)</code> which encapsulate this behavior and simplifies this code to a mere delegation:</p><pre><code class=\"language-ruby\">def grant(person)\n  create_or_find_by(person: person)\nend</code></pre><p>And indeed, this method has made it into Rails 6 and it's arguably what <code>find_or_create_by</code> should have been from the beginning.</p><p>Just a note on the topic of exceptions as a flow control; in this instance, I think it is perfectly fine to do so (<a href=\"https://github.com/rails/rails/blob/f675cb30ce813a99b52b139a93e048330922fd9a/activerecord/lib/active_record/relation.rb#L218\">and in fact the Rails method does just that</a>), because we are relying on the database's mechanism for ensuring data consistency and simply pass the exception through to the caller. We could not have performed this check without dealing with the database exception, since this is the only interface offered to our application code.</p>","url":"http://localhost:2368/on-writing-software-well-part-1/","canonical_url":null,"uuid":"417d7f35-e02b-4545-840b-0bea7d642e0e","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5e7383d91baf0e7fa30dd890","reading_time":4}}]}},"pageContext":{"slug":"software-design","limit":12,"skip":0,"numberOfPages":1,"humanPageNumber":1,"prevPageNumber":null,"nextPageNumber":null,"previousPagePath":null,"nextPagePath":null}}}