{"componentChunkName":"component---src-templates-post-js","path":"/typescript-types-with-complex-properties/","result":{"data":{"ghostPost":{"id":"Ghost__Post__5ee9054642abcc9331f6674f","title":"String<Min, Max> - Defining Types with Complex Properties","slug":"typescript-types-with-complex-properties","featured":false,"feature_image":"https://images.unsplash.com/photo-1582972677567-42a2c06ca9ad?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ","excerpt":"Use a combination of phantom types, type guards and constructor functions  to construct types with complex properties and encode domain logic in our type system.","custom_excerpt":"Use a combination of phantom types, type guards and constructor functions  to construct types with complex properties and encode domain logic in our type system.","visibility":"public","created_at_pretty":"16 June, 2020","published_at_pretty":"20 June, 2020","updated_at_pretty":"21 June, 2020","created_at":"2020-06-16T17:45:42.000+00:00","published_at":"2020-06-20T18:41:19.000+00:00","updated_at":"2020-06-21T08:01:44.000+00:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Jan Bussieck","slug":"jan","bio":null,"profile_image":"//www.gravatar.com/avatar/e056f0b055ea37bd94fdc1664fca6e3d?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Jan Bussieck","slug":"jan","bio":null,"profile_image":"//www.gravatar.com/avatar/e056f0b055ea37bd94fdc1664fca6e3d?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"typescript","slug":"typescript","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"typescript","slug":"typescript","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"An interesting question came up during the Typescript introduction of one of my\nrecent workshops; is it possible to define types that enforce constraints on\ntheir underlying primitives? What if, for instance, I want to define a string\ntype that constrains strings to be within a certain range of characters, or\nmatch a certain format, or have a valid isbn check sum?\n\nIt turns out we can make clever use of phantom types and type guards to create a\ngenerator function that returns types which enforce arbitrary constraints.\n\nBut let's back up a little. For example to define a type for strings that have a\nminimum and maximum length, we first need to ensure that we can't assign\narbitrary strings to it directly. Typescript's never type does just that, it\nindicates that a value never occurs, for example a function that contains an\nevent loop and never returns for the duration of the program:\n\nfunction eventLoop(): never {\n    while(true) {\n       \t//process events\n    }\n}\nlet loop = eventLoop();\nloop = undefined // Error: Type 'undefined' is not assignable to type 'never'.\n\n\nBy contrast returning void here instead of never would allow a value of null or \nundefined to be assigned to loop.\n\nWe can use this special type to define a type StringOfLength<Min, Max> as an\nintersection of a string type and a never type. This allows us to treat a value\nof this type as a string while preventing direct assignment to it:\n\ntype StringOfLength<Min, Max> = string & {\n\t__value__: never\n}\nconst hello: StringOfLength<0, 8> = 'hello' // Type '\"hello\"' is not assignable to type { __value__: never }\n\nIt does not actually matter what name we give to __value__ since it is not\ndirectly assignable anyway. What good is a type if I can't use it, you might\nwonder. It turns out while we can't directly assign a value to a never type we\ncan still cast a value as never and the most common to do so in Typescript is as\nreturn value of a type guard function\n[https://www.typescriptlang.org/docs/handbook/advanced-types.html#using-type-predicates]\n. A type guard is an expression that performs a check at runtime to ensure that\na value is of a certain type. A type guard function then takes some value at\nruntime check whether it meets a certain condition and returns a type predicate,\nwhich takes the form parameterName is Type , parameterName being the name of a\nparameter from the current function signature.\n\nA type guard function for StringOfLength<Min, Max> would consequently check\nwhether a string is within a certain range and return the type predicate str is\nStringOfLength<Min, Max>:\n\nfunction isStringOfLength<Min extends number, Max extends number>(\n  str: string,\n  min: Min,\n  max: Max\n): str is StringOfLength<Min, Max> => str.length >= min && str.length <= max;\n\nAny time isStringOfLength is called with some string, TypeScript will narrow \nthat variable to StringOfLength<Min, Max> if the original type is compatible.\n\nWith this type guard function in hand, we can go ahead and define a simple\nconstructor function for our type:\n\nexport function stringOfLength<Min extends number, Max extends number>(\n  input: unknown,\n  min: Min,\n  max: Max\n): StringOfLength<Min, Max> => {\n  if (typeof input !== \"string\") {\n    throw new Error(\"invalid input\");\n  }\n\n  if (!isStringOfLength(input, min, max)) {\n    throw new Error(`input string is not between specified min ${min} and max ${max}`);\n  }\n\n  return input;\n};\n\nconst hello = stringOfLength('hello', 1, 8) // hello now has type StringOfLength<1,10>\nstringOfLength('buongiorno', 1, 8) // buongiorno\n\nUsing a combination of phantom types, type guards and constructor functions is\nan elegant and powerful way to construct types with complex properties and\nencode domain logic in our type system.\n\nTry it yourself on Stackblitz","html":"<p>An interesting question came up during the Typescript introduction of one of my recent workshops; is it possible to define types that enforce constraints on their underlying primitives? What if, for instance, I want to define a string type that constrains strings to be within a certain range of characters, or match a certain format, or have a valid isbn check sum?</p><p>It turns out we can make clever use of phantom types and type guards to create a generator function that returns types which enforce arbitrary constraints.</p><p>But let's back up a little. For example to define a type for strings that have a minimum and maximum length, we first need to ensure that we can't assign arbitrary strings to it directly. Typescript's <code>never</code> type does just that, it indicates that a value never occurs, for example a function that contains an event loop and never returns for the duration of the program:</p><pre><code class=\"language-javascript\">function eventLoop(): never {\n    while(true) {\n       \t//process events\n    }\n}\nlet loop = eventLoop();\nloop = undefined // Error: Type 'undefined' is not assignable to type 'never'.\n</code></pre><p>By contrast returning <code>void</code> here instead of <code>never</code> would allow a value of <code>null</code> or <code>undefined</code> to be assigned to <code>loop</code>.</p><p>We can use this special type to define a type <code>StringOfLength&lt;Min, Max&gt;</code> as an intersection of a <code>string</code> type and a <code>never</code> type. This allows us to treat a value of this type as a string while preventing direct assignment to it:</p><pre><code class=\"language-javascript\">type StringOfLength&lt;Min, Max&gt; = string &amp; {\n\t__value__: never\n}\nconst hello: StringOfLength&lt;0, 8&gt; = 'hello' // Type '\"hello\"' is not assignable to type { __value__: never }</code></pre><p>It does not actually matter what name we give to <code>__value__</code> since it is not directly assignable anyway. What good is a type if I can't use it, you might wonder. It turns out while we can't directly assign a value to a <code>never</code> type we can still <em>cast</em> a value as <code>never</code> and the most common to do so in Typescript is as return value of a <a href=\"https://www.typescriptlang.org/docs/handbook/advanced-types.html#using-type-predicates\">type guard function</a>. A type guard is an expression that performs a check at runtime to ensure that a value is of a certain type. A type guard function then takes some value at runtime check whether it meets a certain condition and returns a <code>type predicate</code>, which takes the form <code>parameterName is Type</code> , <code>parameterName</code> being the name of a parameter from the current function signature.</p><p>A type guard function for <code>StringOfLength&lt;Min, Max&gt;</code> would consequently check whether a string is within a certain range and return the type predicate <code>str is StringOfLength&lt;Min, Max&gt;</code>:</p><pre><code class=\"language-javascript\">function isStringOfLength&lt;Min extends number, Max extends number&gt;(\n  str: string,\n  min: Min,\n  max: Max\n): str is StringOfLength&lt;Min, Max&gt; =&gt; str.length &gt;= min &amp;&amp; str.length &lt;= max;</code></pre><p>Any time <code>isStringOfLength</code> is called with some string, TypeScript will <em>narrow</em> that variable to <code>StringOfLength&lt;Min, Max&gt;</code> if the original type is compatible.</p><p>With this type guard function in hand, we can go ahead and define a simple constructor function for our type:</p><pre><code class=\"language-javascript\">export function stringOfLength&lt;Min extends number, Max extends number&gt;(\n  input: unknown,\n  min: Min,\n  max: Max\n): StringOfLength&lt;Min, Max&gt; =&gt; {\n  if (typeof input !== \"string\") {\n    throw new Error(\"invalid input\");\n  }\n\n  if (!isStringOfLength(input, min, max)) {\n    throw new Error(`input string is not between specified min ${min} and max ${max}`);\n  }\n\n  return input;\n};\n\nconst hello = stringOfLength('hello', 1, 8) // hello now has type StringOfLength&lt;1,10&gt;\nstringOfLength('buongiorno', 1, 8) // buongiorno</code></pre><p>Using a combination of phantom types, type guards and constructor functions is an elegant and powerful way to construct types with complex properties and encode domain logic in our type system.</p><figure class=\"kg-card kg-embed-card kg-card-hascaption\"><iframe src=\"https://stackblitz.com/edit/typescript-complex-types?embed=1\" height=\"400\" width=\"745\"></iframe><figcaption>Try it yourself on Stackblitz</figcaption></figure>","url":"http://localhost:2368/typescript-types-with-complex-properties/","canonical_url":null,"uuid":"57f16584-a497-47a2-a139-c9b9de930a23","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5ee9054642abcc9331f6674f","reading_time":2}},"pageContext":{"slug":"typescript-types-with-complex-properties"}}}